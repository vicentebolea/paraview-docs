<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ParaView: Plugin Howto</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea" style="height: 56px;">
  <div class="pv-title-cpp title-line">
    <div class="title-line">
      <img class="pv-logo" src="paraview-logo-small.png" />
    </div>
    <div class="langSwitch title-line"></div>
  </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Plugin Howto </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>ParaView comes with plethora of functionality bundled in: several readers, multitude of filters, different types of views, etc. However, it is not uncommon for developers to want to add new functionality to ParaView to, for example, add support to their new file format or incorporate a new filter into ParaView. ParaView makes it possible to add new functionality by using an extensive plugin mechanism.</p>
<p>Plugins can be used to extend ParaView in several ways:</p>
<ul>
<li>Add new readers, writers, filters</li>
<li>Add custom GUI components such as toolbar buttons to perform common tasks</li>
<li>Add new views in for display data</li>
</ul>
<p>Examples for different types of plugins are provided with the ParaView source under <code>Examples/Plugins/</code>.</p>
<p>This document has major sections:</p>
<ul>
<li>First section covers how to use existing plugins in ParaView.</li>
<li>Second section contains information for developers about writing new plugins for ParaView.</li>
</ul>
<h2>Using Plugins</h2>
<h3>Types of plugins</h3>
<p>Plugins are distributed as shared libraries (<code>*.so</code> on Unix and macOS, and <code>*.dll</code> on Windows). For a plugin to be loadable in ParaView, it must be built with the same version of ParaView as it is expected to be deployed on. Plugins can be classified into two broad categories:</p>
<ul>
<li><em>Server-side plugins</em>: These are plugins that extend the algorithmic capabilities for ParaView. For example, new filters, readers or writers. Since ParaView processes data on the server-side, these plugins need to be loaded on the server.</li>
<li><em>Client-side plugins</em>: These are plugins that extend the ParaView GUI including property panels for new filters, toolbars or views. These plugins need to be loaded on the client.</li>
</ul>
<p>Oftentimes a plugin has both server-side as well as client-side components to it. For example, a plugin that adds a new filter and a property panel that goes with that filter. Such plugins need to be loaded both on the server as well as the client.</p>
<p>Generally, users don't have to worry whether a plugin is a server-side or client-side plugin. Simply load the plugin on the server as well as the client. ParaView will include relevant components from plugin on each of the processes.</p>
<h3>Loading plugins</h3>
<p>There are four ways for loading plugins:</p>
<ul>
<li><em>Using the GUI</em> (<code>Plugin Manager</code>)<ul>
<li>Plugins can be loaded into ParaView using the <code>Plugin Manager</code> accessible from the <code>Tools | Manage Plugins/Extensions</code> menu. The <code>Plugin Manager</code> has two sections for loading client plugins and server plugins (shown only when connected to a server). To load a plugin on the client and server side, simply browse to the plugin shared library. If the plugin is loaded successfully, it will appear in the list of loaded plugins. The <code>Plugin Manager</code> also lists the paths it searched to load plugins automatically.</li>
<li>The <code>Plugin Manager</code> remembers all loaded plugins across ParaView instances, so once a plugin is loaded once, it will appear in the future (unloaded).</li>
<li>You can set up ParaView to automatically load the plugin at startup (for client plugins) or on connecting to the server (for server plugins) by checking the "Auto Load" checkbox on a loaded plugin.</li>
</ul>
</li>
</ul>
<div class="image">
<img src="images/LocalPlugin_Manager.png"  alt="Plugin Manager when not connected to a remote server, showing loaded plugins on the local site."/>
</div>
 <div class="image">
<img src="images/RemotePlugin_Manager.png"  alt="Plugin Manager when connected to a server showing loaded plugins on the local as well as remote sites."/>
</div>
<ul>
<li><em>Using environment variable</em> (Auto-loading plugins)<ul>
<li>In order to have ParaView automatically load a set of plugins on startup, one can use the <code>PV_PLUGIN_PATH</code> environment variable. <code>PV_PLUGIN_PATH</code> may be used to list a set of directories (separated by colon (<code>:</code>) for Unix platforms or semi-colon (<code>;</code>) on Windows) which ParaView will search on startup to load plugins. This environment variable needs to be set on both the client and server sides to load their respective plugins. Note that plugins in PV_PLUGIN_PATH are always auto-loaded irrespective of the status of the <code>Auto Load</code> checkbox in the <code>Plugin Manager</code>. Paths in this list may also be of the structure created by the ParaView plugin macros (e.g., <code>MyPlugin/MyPlugin.so</code>).</li>
<li>Finer control can be used using the <code>PV_PLUGIN_CONFIG_FILE</code> environment variable. <code>PV_PLUGIN_CONFIG_FILE</code> can be used to list a set of XML plugin configuration files (separated by colon (<code>:</code>) on Unix platforms or semi-colon (<code>;</code>) on Windows). ParaView will read these files on startup to load specified plugins. The XML plugin configuration file format looks like this:</li>
</ul>
</li>
</ul>
<p>```xml &lt;?xml version="1.0"?&gt; &lt;Plugins&gt; &lt;Plugin name="MyPlugin" filename="/absolute/path/to/libMyPlugin.so"&gt;</p>
<p>&lt;Plugin name="MyPluginRel" filename="relative/path/to/libMyPlugin.so"&gt; &lt;/Plugins&gt; ``` </p>
<pre class="fragment">  Plugins listed this way will always be loaded, irrespective of the status
  of the `Auto Load` checkbox in the `Plugin Manager`.
</pre><ul>
<li><em>Using the plugin file <code>.plugins</code></em> (Make plugins available and possibly Auto-load plugins)<ul>
<li>Plugins that are listed in the <code>.plugins</code> file on the client and server will automatically be listed in the <code>Plugin Manager</code>, and may optionally be auto loaded. ParaView creates its own <code>.plugins</code> file listing plugins known during its build and uses it as the default. An example <code>.plugins</code> file, auto loading H5PartReader, looks like this:</li>
</ul>
</li>
</ul>
<p>```xml &lt;?xml version="1.0"?&gt; &lt;Plugins&gt; &lt;Plugin name="Moments" auto_load="0"&gt; &lt;Plugin name="PrismPlugin" auto_load="0"&gt; &lt;Plugin name="PointSprite_Plugin" auto_load="0"&gt; &lt;Plugin name="pvblot" auto_load="0"&gt; &lt;Plugin name="H5PartReader" auto_load="1"&gt; &lt;/Plugins&gt; ```</p>
<ul>
<li><em>Default search paths</em><ul>
<li>Recognized locations are:<ul>
<li>A <code>plugins</code> subdirectory under the <code>paraview-X.Y</code> directory in the library path (usually <code>lib</code> on Unix platforms and <code>bin</code> on Windows).</li>
<li>A <code>plugins</code> subdirectory in the user's home directory. On Unix platforms, <code>$HOME/.config/ParaView/ParaView&lt;version&gt;/Plugins</code>. On Windows <code>APPDATA$\ParaView\ParaView&lt;version&gt;\Plugins</code>. (XXX: no evidence of an implementation backing this search path).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Debugging Plugins</h2>
<p>If plugin loading fails, the <code>PV_PLUGIN_DEBUG</code> environment variable may be set for either the client or server processes. ParaView will then print verbose information about each step and causes for failure, as show below.</p>
<p>``` </p>
<hr/>
<p> Attempting to load /home/utkarsh/Kitware/ParaView3/ParaView3Bin/bin/libSurfaceLIC.so Loaded shared library successfully. Now trying to validate that it's a ParaView plugin. Updating Shared Library Paths: /home/utkarsh/Kitware/ParaView3/ParaView3Bin/bin </p>
<h2>Plugin instance located successfully. Now loading components from the plugin instance based on the interfaces it implements. </h2>
<p>Plugin Information: Name : SurfaceLIC Version : 1.0 ReqOnServer : 1 ReqOnClient : 1 ReqPlugins : ServerManager Plugin : Yes Python Plugin : No ```</p>
<h1>Writing plugins</h1>
<p>This section covers writing and compiling different types of Plugins. To create a plugin, one must have their own build of ParaView. Binaries downloaded from www.paraview.org do not include necessary header files or import libraries (where applicable) for compiling plugins.</p>
<p>The <code>CMakeLists.txt</code> file used in all following examples start off with the following code:</p>
<p>```cmake </p>
<h1>ParaView requires CMake 3.8 in order to be used.</h1>
<p>cmake_minimum_required(VERSION 3.8) project(myplugin C CXX)</p>
<p>find_package(ParaView REQUIRED) ```</p>
<p>Where CMake will ask for the <code>ParaView_DIR</code> which you point to the ParaView build or install tree you would to build your with.</p>
<p>Note that the <code>C</code> and <code>CXX</code> languages are required in general because ParaView may need to find other packages which are written with only C in mind (MPI is the usual culprit here) and need to know about the C compiler that is available.</p>
<h2>Exposing an Existing Filter</h2>
<p>Sometimes, the filter that one wants to add to ParaView is already available in VTK, it's just not exposed through the ParaView GUI. This is the easiest type of plugin to create. There are two options:</p>
<ol type="1">
<li>setup the plugin using only an XML file; and</li>
<li>actually compile the plugin into a shared library.</li>
</ol>
<p>The first option is the easiest, but the second option will prepare you for creating a custom filter in the future as the process is nearly identical.</p>
<h2>Adding a New Filter</h2>
<p>It is also possible to add new filters to ParaView. The filter has to be a VTK-based algorithm, written as following the standard procedures for writing VTK algorithms. Generally for such cases where we are adding a new VTK class to ParaView (be it a filter, reader or a writer), we need to do the following tasks:</p>
<ul>
<li>Write a <em>Server Manager Configuration XML</em> which describes the <code>Proxy</code> interface for the filter. Basically, this defines the interface for the client to create and modify instances of the new class on the server side. Please refer to the <a href="http://www.kitware.com/products/books/paraview.html">ParaView Guide</a> for details about writing these server-manager XMLs.</li>
<li>Write a configuration XML for the GUI to make ParaView GUI aware of this new class, if applicable. For filters, this is optional, since ParaView automatically recognizes filters added through plugins and lists them in the <em>Alphabetical</em> sub-menu. One may use the GUI configuration XML to add the new filter to a specific category in the <em>Filters</em> menu, or add a new category. For readers and writers, this is required since ParaView GUI needs to know what extensions your reader/writer supports etc.</li>
</ul>
<h2>Examples</h2>
<h3>XML Plugins</h3>
<p>If you have not built ParaView from source, using an XML plugin is your only option.</p>
<p>First, a server manager XML for the filter is required. The GUI XML to add the filter to any specific category is optional.</p>
<p>For example, let's say we simply want to expose the <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkCellDerivatives.html">vtkCellDerivatives</a></code> filter in VTK. Then first, we'll write the server manager configuration XML (call it <code>CellDerivatives.xml</code>), similar to what we would have done for adding a new filter.</p>
<p>```xml &lt;ServerManagerConfiguration&gt; &lt;ProxyGroup name="filters"&gt; &lt;SourceProxy name="MyCellDerivatives" class="vtkCellDerivatives" label="My Cell Derivatives"&gt; &lt;Documentation long_help="Create point attribute array by projecting points onto an elevation vector." short_help="Create a point array representing elevation."&gt; &lt;/Documentation&gt; &lt;InputProperty name="Input" command="SetInputConnection"&gt; &lt;ProxyGroupDomain name="groups"&gt; &lt;Group name="sources"&gt; &lt;Group name="filters"&gt; &lt;/ProxyGroupDomain&gt; &lt;DataTypeDomain name="input_type"&gt; &lt;DataType value="vtkDataSet"&gt; &lt;/DataTypeDomain&gt; &lt;/InputProperty&gt; &lt;/SourceProxy&gt; &lt;/ProxyGroup&gt; &lt;/ServerManagerConfiguration&gt; ```</p>
<p>At this point, we can stop and use the plugin in ParaView by loading the XML file directly into the plugin manager.</p>
<p>Please note that if you are writing the XML for a filter that takes just one input, you <em>must</em> set the <code>name</code> attribute for the <code>InputProperty</code> XML element to <code>Input</code>. If you do not, then the filter will not be displayed properly in ParaView's pipeline browser.</p>
<h3>Compiling into a Shared Library</h3>
<p>If you have built ParaView from source, it is possible to compile the plugin into into a shared library. To do this, we can use the following top-level: <code>CMakeLists.txt</code>:</p>
<p>``<code>cmake &lt;h1&gt;Standard CMake boilerplate. ParaView's</code>find_package` requires at least 3.8. cmake_minimum_required(VERSION 3.8) project(sharedlibrary)</p>
<h1>These five lines are required in order to set up installation directories</h1>
<h1>(which also control build directory locations) and enable shared builds</h1>
<h1>(CMake's default is for a static build).</h1>
<p>include(GNUInstallDirs) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR}") set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR}") set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR}") set(BUILD_SHARED_LIBS ON)</p>
<h1>Find ParaView. This will bring in ParaView's CMake API and imported targets.</h1>
<p>find_package(ParaView REQUIRED)</p>
<h1>Scan the plugin file in order to set up internal data structures for building</h1>
<h1>plugins.</h1>
<p>paraview_plugin_scan( </p>
<h1>The <code>paraview.plugin</code> file describing the plugin.</h1>
<p>PLUGIN_FILES "${CMAKE_CURRENT_SOURCE_DIR}/Plugin/paraview.plugin" </p>
<h1>A result variable for the (enabled) plugins found during the scan.</h1>
<p>PROVIDES_PLUGINS plugins </p>
<h1>Enable plugins during this scan by default.</h1>
<p>ENABLE_BY_DEFAULT ON)</p>
<h1>Build the plugins discovered during the scan.</h1>
<p>paraview_plugin_build( PLUGINS ${plugins}) ```</p>
<p>The mentioned <code>paraview.plugin</code> file describes the plugin to the build system:</p>
<p>```cmake NAME CellDerivatives DESCRIPTION Expose the <a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkCellDerivatives.html">vtkCellDerivatives</a> class to ParaView. REQUIRES_MODULES </p>
<h1>This module provides the <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkCellDerivatives.html">vtkCellDerivatives</a></code> filter.</h1>
<p>VTK::FiltersGeneral ```</p>
<p>In the <code>Plugin</code> directory (beside the <code>paraview.plugin</code> file), the plugin is given the information it needs to build:</p>
<p>```cmake paraview_add_plugin(CellDerivatives VERSION "1.0" SERVER_MANAGER_XML CellDerivatives.xml) ```</p>
<p>Then using CMake, one can build a plugin for this new filter. We can now load the plugin through the plugin manager by selecting the created <code>.so</code> or <code>.dll</code> file.</p>
<h3>Qt resource plugins</h3>
<p>Similarly compiled Qt resources (<code>*.bqrc</code>) can be loaded at runtime. A <code>.bqrc</code> file is a binary file containing resources which can include icons, the GUI configuration XML for adding categories, etc. A <code>.bqrc</code> can be made from a <code>.qrc</code> by running the <code>rcc</code> utility provided by Qt:</p>
<p>```sh rcc -binary -o myfile.bqrc myfile.qrc ```</p>
<h3>Adding a New Filter</h3>
<p>For this example, refer to <code>Examples/Plugins/ElevationFilter</code> in the ParaView source. Let's say we have written a new <code>vtkMyElevationFilter</code> (<code>vtkMyElevationFilter.{h,cxx}</code>), which extends the functionality of the <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkElevationFilter.html">vtkElevationFilter</a></code> and we want to package that as a plugin for ParaView. For starters, we simply want to use this filter in ParaView (e.g., not doing anything fancy with <em>Filters</em> menu categories). As described, we need to write the server manager configuration XML (<code>MyElevationFilter.xml</code>). Once that's done, we write a <code>CMakeLists.txt</code> file to package this into a plugin.</p>
<p>This <code>CMakeLists.txt</code> needs to include the following lines:</p>
<p>```cmake cmake_minimum_required(VERSION 3.8) project(newfilter)</p>
<p>include(GNUInstallDirs) set(BUILD_SHARED_LIBS ON)</p>
<p>find_package(ParaView REQUIRED)</p>
<p>paraview_plugin_scan( PLUGIN_FILES "${CMAKE_CURRENT_SOURCE_DIR}/Plugin/paraview.plugin" PROVIDES_PLUGINS plugins ENABLE_BY_DEFAULT ON)</p>
<p>paraview_plugin_build( PLUGINS ${plugins}) ```</p>
<p>The referenced <code>paraview.plugin</code> file contains:</p>
<p>```cmake NAME ElevationFilter DESCRIPTION An example paraview plugin containing server manager XML and the server manager classes to build. This plugin can be loaded on the server side. REQUIRES_MODULES VTK::CommonCore VTK::FiltersCore ```</p>
<p>And the <code>CMakeLists.txt</code> file beside it contains:</p>
<p>```cmake paraview_add_plugin(ElevationFilter VERSION "1.0" MODULES ElevationFilters MODULE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/ElevationFilters/vtk.module") ```</p>
<p>Because we are building our own custom filter, it needs to be a VTK module in order to support having its information available to the XML code. First, the module is declared in a <code>vtk.module</code> file:</p>
<p>```cmake NAME ElevationFilters DEPENDS VTK::FiltersCore PRIVATE_DEPENDS VTK::CommonCore ```</p>
<p>And then the module is built with its associated server manager XML file attached to the module. Note that the module name cannot be the same as the plugin name due to the way the library targets are managed internally.</p>
<p>```cmake set(classes vtkMyElevationFilter)</p>
<h1>Find external packages here using <code>find_package</code>.</h1>
<p>vtk_module_add_module(ElevationFilters CLASSES ${classes})</p>
<h1>Link to external packages here using <code>vtk_module_link(ElevationFilters)</code>.</h1>
<p>paraview_add_server_manager_xmls( XMLS MyElevationFilter.xml) ```</p>
<p>Then using CMake, one can build a plugin for this new filter. Once this plugin is loaded the filter will appear under the <em>Alphabetical</em> list in the <em>Filters</em> menu. Note that there will be two libraries in the resulting directory. Be sure to load the <code>ElevationFilter</code> one which is the plugin, not the <code>ElevationFilters</code> module library.</p>
<h3>Filters with Multiple Input Ports</h3>
<p>If a filter requires multiple input ports, there are two options:</p>
<ol type="1">
<li>Create helper functions in the VTK filter such as <code>SetYourInputName</code> which deal with addressing the VTK pipeline in the C++ code; and</li>
<li>Address/access the input connection by number in the XML. The <code>port_index</code> property specifies which input connection the particular input will be connected to. The <code>SetInputConnection</code> function is the command that will actually be called with this <code>port_index</code> to setup the pipeline.</li>
</ol>
<p>An example XML file for a filter with multiple inputs is below. The filter takes three <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkPolyData.html">vtkPolyData</a></code> objects as input.</p>
<p>```xml &lt;ServerManagerConfiguration&gt; &lt;ProxyGroup name="filters"&gt; &lt;SourceProxy name="LandmarkTransformFilter" class="vtkLandmarkTransformFilter" label="LandmarkTransformFilter"&gt; &lt;Documentation long_help="Align two point sets using vtkLandmarkTransform to compute the best transformation between the two point sets." short_help="vtkLandmarkTransformFilter."&gt; &lt;/Documentation&gt;</p>
<p>&lt;InputProperty name="SourceLandmarks" port_index="0" command="SetInputConnection"&gt; &lt;ProxyGroupDomain name="groups"&gt; &lt;Group name="sources"&gt; &lt;Group name="filters"&gt; &lt;/ProxyGroupDomain&gt; &lt;DataTypeDomain name="input_type"&gt; &lt;DataType value="vtkPolyData"&gt; &lt;/DataTypeDomain&gt; &lt;Documentation&gt; Set the source data set. This data set that will move towards the target data set. &lt;/Documentation&gt; &lt;/InputProperty&gt;</p>
<p>&lt;InputProperty name="TargetLandmarks" port_index="1" command="SetInputConnection"&gt; &lt;ProxyGroupDomain name="groups"&gt; &lt;Group name="sources"&gt; &lt;Group name="filters"&gt; &lt;/ProxyGroupDomain&gt; &lt;DataTypeDomain name="input_type"&gt; &lt;DataType value="vtkPolyData"&gt; &lt;/DataTypeDomain&gt; &lt;Documentation&gt; Set the target data set. This data set will stay stationary. &lt;/Documentation&gt; &lt;/InputProperty&gt;</p>
<p>&lt;InputProperty name="SourceDataSet" port_index="2" command="SetInputConnection"&gt; &lt;ProxyGroupDomain name="groups"&gt; &lt;Group name="sources"&gt; &lt;Group name="filters"&gt; &lt;/ProxyGroupDomain&gt; &lt;DataTypeDomain name="input_type"&gt; &lt;DataType value="vtkPolyData"&gt; &lt;/DataTypeDomain&gt; &lt;Documentation&gt; Set the source data set landmark points. &lt;/Documentation&gt; &lt;/InputProperty&gt;</p>
<p>&lt;Hints&gt;</p>
<p>&lt;/Hints&gt;</p>
<p>&lt;/SourceProxy&gt; &lt;/ProxyGroup&gt; &lt;/ServerManagerConfiguration&gt; ```</p>
<p>To set the inputs in ParaView, simply select one of the inputs in the <em>Pipeline Browser</em> and then select the filter from the <em>Filters</em> menu. This will open a dialog box which will allow you to specify which object to connect to each input port.</p>
<h3>Adding <em>Categories</em> to the <em>Filters</em> Menu</h3>
<p>Now suppose we want to add a new category to the <em>Filters</em> menu, called <em>Extensions</em> and then show this filter in that menu. In that case we need to add a hint to the XML file that tells ParaView what category to display this filter in. In this case, the <code>Hints</code> element of the XML file can contain:</p>
<p>```xml &lt;Hints&gt; &lt;ShowInMenu category="Extensions"&gt; &lt;/Hints&gt; ```</p>
<p>If the name of the category is same as an already existing category such as <em>Data Analysis</em>, then the filter gets added to the existing category.</p>
<h3>Adding Icons</h3>
<p>You can see that some filters in the <em>Filters</em> menu (e.g., <em>Clip</em>) have icons associated with them. It's possible for the plugin to add icons for filters it adds as well. For that you need to write a Qt resource file (say <code>MyElevation.qrc</code>) as follows:</p>
<p>```xml &lt;RCC&gt; &lt;qresource prefix="/MyIcons"&gt; &lt;file&gt;MyElevationIcon.png&lt;/file&gt; &lt;/qresource&gt; &lt;/RCC&gt; ```</p>
<p>To use the icon for a filter in the pipeline add the following hint to the server manager XML.</p>
<p>```xml &lt;Hints&gt; &lt;ShowInMenu icon=":/MyIcons/MyElevationIcon.png"&gt; &lt;/Hints&gt; ```</p>
<p>Finally, the plugin's <code>CMakeLists.txt</code> file much change to include our <code>MyElevation.qrc</code> file as follows:</p>
<p>```cmake paraview_add_plugin(ElevationFilter VERSION "1.0" MODULES ElevationFilters MODULE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/ElevationFilters/vtk.module" UI_RESOURCES MyElevation.qrc) ```</p>
<h3>Adding GUI Parameters</h3>
<p>Simply add these in the server manager XML to expose parameters of the filter to the ParaView user.</p>
<h4>Integer Property</h4>
<p>This property appears as a text box.</p>
<p>```xml &lt;IntVectorProperty name="bStartByMatchingCentroids" command="SetbStartByMatchingCentroids" number_of_elements="1" default_values="1"&gt; &lt;/IntVectorProperty&gt; ```</p>
<h4>Boolean Property</h4>
<p>This property appears as a check box control. A boolean property uses the <code>IntVectorProperty</code> with an extra line (<code>BooleanDomain</code>) indicating this should be a check box rather than a text field.</p>
<p>```xml &lt;IntVectorProperty name="bStartByMatchingCentroids" command="SetbStartByMatchingCentroids" number_of_elements="1" default_values="1"&gt; &lt;BooleanDomain name="bool"&gt; &lt;/IntVectorProperty&gt; ```</p>
<h4>String Property</h4>
<p>This property appears as a text box.</p>
<p>```xml &lt;StringVectorProperty name="YourStringVariable" command="SetYourStringVariable" number_of_elements="1" default_values="1"&gt; &lt;/StringVectorProperty&gt; ```</p>
<h4>Double Property</h4>
<p>This property appears as a text box.</p>
<p>```xml &lt;DoubleVectorProperty name="YourDoubleVariable" command="SetYourDoubleVariable" number_of_elements="1" default_values="1"&gt; &lt;/DoubleVectorProperty&gt; ```</p>
<h4>Multi-Value Double Property</h4>
<p>This property appears as a text box.</p>
<p>```xml &lt;DoubleVectorProperty name="YourDoubleVectorVariable" command="SetYourDoubleVectorVariable" number_of_elements="3" default_values="1.0 0.0 0.0"&gt; &lt;/DoubleVectorProperty&gt; ```</p>
<h4>Double Property Slider</h4>
<p>This creates a slider that ranges from <code>0.0</code> to <code>1.0</code>.</p>
<p>```xml &lt;DoubleVectorProperty name="PercentToRemove" command="SetPercentToRemove" number_of_elements="1" default_values="0.1"&gt; &lt;DoubleRangeDomain name="range" min="0.0" max="1.0"&gt; &lt;/DoubleVectorProperty&gt; ```</p>
<h4>Drop Down List</h4>
<p>This creates a drop down list with 3 choices. The values associated with the choices may be specified.</p>
<p>```xml &lt;IntVectorProperty name="TransformMode" command="SetTransformMode" number_of_elements="1" default_values="1"&gt; &lt;EnumerationDomain name="enum"&gt; &lt;Entry value="6" text="RigidBody"&gt; &lt;Entry value="7" text="Similarity"&gt; &lt;Entry value="12" text="Affine"&gt; &lt;/EnumerationDomain&gt; &lt;Documentation&gt; This property indicates which transform mode will be used. &lt;/Documentation&gt; &lt;/IntVectorProperty&gt; ```</p>
<h4>Drop Down List with Values from Input Arrays</h4>
<p>This creates a list that lets you choose among the input arrays of the input of a <code>ProgrammableFilter</code>:</p>
<p>```xml &lt;StringVectorProperty name="SelectInputScalars" label="Array" command="SetInputArrayToProcess" number_of_elements="5" element_types="0 0 0 0 2" animateable="0"&gt; &lt;ArrayListDomain name="array_list" attribute_type="Scalars" input_domain_name="inputs_array"&gt; &lt;RequiredProperties&gt; &lt;Property name="Input" function="Input"&gt; &lt;/RequiredProperties&gt; &lt;/ArrayListDomain&gt; &lt;/StringVectorProperty&gt; ```</p>
<p>This will look like the following image:</p>
<div class="image">
<img src="images/DropboxWithInputArrays.jpg"  alt="Drop down list with values from input arrays"/>
</div>
<h4>Drop Down List with Values from Input File</h4>
<p>If you need to populate a list with values from a file and be able to select/deselect list entries (e.g., to pick which variables are loaded from the file), use a XML similar to this:</p>
<p>```xml &lt;StringVectorProperty information_only="1" name="CellArrayInfo"&gt; &lt;ArraySelectionInformationHelper attribute_name="Cell"&gt; &lt;/StringVectorProperty&gt; &lt;StringVectorProperty command="SetCellArrayStatus" element_types="2 0" information_property="CellArrayInfo" label="Cell Arrays" name="CellArrayStatus" number_of_elements="0" number_of_elements_per_command="2" repeat_command="1"&gt; &lt;ArraySelectionDomain name="array_list"&gt; &lt;RequiredProperties&gt; &lt;Property function="ArrayList" name="CellArrayInfo"&gt; &lt;/RequiredProperties&gt; &lt;/ArraySelectionDomain&gt; &lt;Documentation&gt; This property lists which cell-centered arrays to read. &lt;/Documentation&gt; &lt;/StringVectorProperty&gt; ```</p>
<p>You can see an example in use in ParaView's <a href="https://gitlab.kitware.com/paraview/paraview/-/blob/87babdbeab6abe20aac6f8b2692788abc6bb20ac/ParaViewCore/ServerManager/SMApplication/Resources/readers.xml#L158-179">core readers</a> XML.</p>
<p>You may also do it in the following manner:</p>
<p>```xml &lt;StringVectorProperty command="SetCellArrayStatus" element_types="2 0" information_property="CellArrayInfo" label="Cell Arrays" name="CellArrayStatus" number_of_elements="0" number_of_elements_per_command="2" repeat_command="1"&gt; &lt;ArrayListDomain name="array_list" attribute_type="Scalars" input_domain_name="inputs_array"&gt; &lt;RequiredProperties&gt; &lt;Property name="Input" function="Input"&gt; &lt;/RequiredProperties&gt; &lt;/ArrayListDomain&gt; &lt;/StringVectorProperty&gt; ```</p>
<p>In which case the result will look like this:</p>
<div class="image">
<img src="images/DropdownListFromFile.jpg"  alt="Drop down list with values from input file"/>
</div>
<h4>Adding a Reader</h4>
<p>Adding a new reader through a plugin is similar to adding a filter. The only difference is that we do not need to specify what category the reader should be added to in the GUI. For the latest version of ParaView we do not need to specify anything special for the GUI as all of the details of the reader are available in the XML proxy definition of the reader. For ParaView version 4.0.1 and earlier we need the XML to define what file extensions this reader can handle. This XML (<code>MyReaderGUI.xml</code>) looks like this:</p>
<p>```xml &lt;ParaViewReaders&gt; &lt;Reader name="MyPNGReader" extensions="png" file_description="My PNG Files"&gt; &lt;/Reader&gt; &lt;/ParaViewReaders&gt; ```</p>
<p>An example <code>MyPNGReader.xml</code> is shown below. In almost all cases you must have a <code>SetFileName</code> function property. You are free to have other properties as well, as with a standard (non-reader) filter. Also, the <code>Hints</code> section is needed in order to associate the file extension with the reader on the client. The <code>ReaderFactory</code> hint is what the client uses to identify readers from sources.</p>
<p>```xml &lt;ServerManagerConfiguration&gt; &lt;ProxyGroup name="sources"&gt; &lt;SourceProxy name="MyPNGReader" class="vtkMyPNGReader" label="PNGReader"&gt; &lt;Documentation long_help="Read a PNG file." short_help="Read a PNG file."&gt; &lt;/Documentation&gt; &lt;StringVectorProperty name="FileName" animateable="0" command="SetFileName" number_of_elements="1"&gt; &lt;FileListDomain name="files"&gt; &lt;Documentation&gt; This property specifies the file name for the PNG reader. &lt;/Documentation&gt; &lt;/StringVectorProperty&gt; &lt;Hints&gt; &lt;ReaderFactory extensions="png" file_description="PNG File Format"&gt; &lt;/Hints&gt; &lt;/SourceProxy&gt; &lt;/ProxyGroup&gt; &lt;/ServerManagerConfiguration&gt; ```</p>
<p>The CMake code for a reader plugin uses the same structure as the filter example. The only likely difference is that the plugin should also pass <code>REQUIRED_ON_SERVER</code> to <code>paraview_add_plugin</code> since the server side needs the reader available for its use.</p>
<p>If you want your reader to work correctly with a file series, please refer to [[Animating legacy VTK file series::Making custom readers work with file series|file series animation]] for details.</p>
<p>Once you generate the project using CMake and compile the project, in ParaView go to <em>Tools &gt; Manage Plugins/Extensions</em>. Under <em>Local Plugins</em>, click <em>Load New</em> and browse for the shared library file you just created. You should now see your new file type in the <em>Files of type</em> list in the <em>Open file</em> dialog.</p>
<h4>Adding a Writer</h4>
<p>Similar to a reader plugin, for a writer plugin we need to tell ParaView what extensions this writer supports. For the current version of ParaView this is done in the <code>Hints</code> section of the server manager XML definition as follows:</p>
<p>```xml &lt;Hints&gt; &lt;WriterFactory extensions="tif" file_description="My Tiff Files"&gt; &lt;/Hints&gt; ```</p>
<h4>Adding Customizations for Properties Panel</h4>
<p>[[ParaView/Properties Panel|Properties Panel]] is the primary panel in ParaView used to change the parameters for visualization modules and displays. Plugins can provide new types of <a href="https://kitware.github.io/paraview-docs/nightly/cxx/classpqPropertyWidget.html">`pqPropertyWidget`</a> subclasses that can be used to control properties/property groups on this Properties panel.</p>
<p>To register a new <code><a class="el" href="classpqPropertyWidget.html" title="pqPropertyWidget represents a widget created for each property of a proxy on the pqPropertiesPanel (f...">pqPropertyWidget</a></code> subclass to be associated with a particular widget type for a property (<code><a class="el" href="classvtkSMProperty.html" title="superclass for all SM properties ">vtkSMProperty</a></code>), use the following CMake code in your plugin:</p>
<p>```cmake paraview_plugin_add_property_widget KIND kind TYPE my_property_widget_type CLASS_NAME ClassName INTERFACES interfaces SOURCES sources)</p>
<p>paraview_add_plugin(propwidget VERSION "1.0" UI_INTERFACES ${interfaces} SOURCES ${sources}) ```</p>
<p>The <code>KIND</code> argument must be one of <code>WIDGET</code>, <code>GROUP_WIDGET</code>, or <code>WIDGET_DECORATOR</code>. For a <code><a class="el" href="classvtkSMProperty.html" title="superclass for all SM properties ">vtkSMProperty</a></code>, <code>WIDGET</code> is required.</p>
<p>The <code>CLASS_NAME</code> argument must refer to a <code><a class="el" href="classpqPropertyWidget.html" title="pqPropertyWidget represents a widget created for each property of a proxy on the pqPropertiesPanel (f...">pqPropertyWidget</a></code> subclass with a constructor with the following signature:</p>
<p>```cpp ClassName(vtkSMProxy &lt;em&gt;smproxy, vtkSMProperty *smproperty, QWidget *parentObject) ```</p>
<p>The <code>TYPE</code> argument specifies the string that will be used in the server manager XML as the value for the <code>panel_widget</code> attribute to request creation of this widget for a <code><a class="el" href="classvtkSMProperty.html" title="superclass for all SM properties ">vtkSMProperty</a></code> subclass.</p>
<p>To register a new <code><a class="el" href="classpqPropertyWidget.html" title="pqPropertyWidget represents a widget created for each property of a proxy on the pqPropertiesPanel (f...">pqPropertyWidget</a></code> subclass to be associated with a particular widget type for a property group (<code><a class="el" href="classvtkSMPropertyGroup.html">vtkSMPropertyGroup</a></code>), use <code>GROUP_WIDGET</code> for the <code>KIND</code> argument. The referenced <code>CLASS_NAME</code> must subclass <code><a class="el" href="classpqPropertyWidget.html" title="pqPropertyWidget represents a widget created for each property of a proxy on the pqPropertiesPanel (f...">pqPropertyWidget</a></code> and have a constructor with the signature:</p>
<p>```cpp ClassName(vtkSMProxy *smproxy, vtkSMPropertyGroup *smgroup, QWidget *parentObject); ```</p>
<p>As before, the <code>TYPE</code> specifies the string that will be used in the server manager XML as the value for the <code>panel_widget</code> attribute on a <code>PropertyGroup</code> element to request creation of this widget for that group.</p>
<p>Another mechanism for adding customizations for <em>Properties</em> panel is to provide <a href="https://kitware.github.io/paraview-docs/nightly/cxx/classpqPropertyWidgetDecorator.html">`pqPropertyWidgetDecorator`</a> subclasses to add custom control logic for widgets on the panel.</p>
<p>Decorators use the <code>WIDGET_DECORATOR</code> argument to <code>KIND</code>.</p>
<p>The <code>CLASS_NAME</code> must point to a <code><a class="el" href="classpqPropertyWidgetDecorator.html" title="pqPropertyWidgetDecorator provides a mechanism to decorate pqPropertyWidget instances to add logic to...">pqPropertyWidgetDecorator</a></code> subclass and the <code>TYPE</code> is the string name used to request the creation of the decorator in the server manager XML as described [[ParaView/Properties Panel|here]].</p>
<p>An example for customizing the Properties panel can be found in the ParaView source under <code>Examples/Plugins/PropertyWidgets</code>.</p>
<h4>Adding Documentation for Plugins</h4>
<p>Developers can provide documentation for plugins that is shown in ParaView's *Help window. There are two mechanisms for adding documentation from plugins.</p>
<ul>
<li>Any server manager XML files added directly to the <code>paraview_add_plugin</code> function or those attached to modules passed to its <code>MODULES</code> argument using <code>paraview_add_server_manager_xmls</code> are automatically parsed to process <code>Documentation</code> elements. HTML pages summarizing the proxy and properties are automatically generated. This ensures that when the user clicks "?" for a filter or source added via the plugin, the help window shows appropriate help pages.</li>
<li>Using the <code>DOCUMENTATION_DIR</code> argument to <code>paraview_add_plugin</code> to specify a directory containing HTML pages and images that gets added a the documentation for the plugin (in addition to the documentation generated using the <code>SERVER_MANAGER_XML</code> files. For example:</li>
</ul>
<p>```cmake paraview_add_plugin(SurfaceLIC VERSION "1.0" DOCUMENTATION_DIR "${CMAKE_CURRENT_SOURCE_DIR}/doc") ```</p>
<p>This results in adding documentation to the <em>ParaView Online Help</em> when the plugin is loaded, as shown below.</p>
<div class="image">
<img src="images/Paraview_doc_plugin.png" />
</div>
<h4>Adding a Toolbar</h4>
<p>Filters, reader, and writers are by far the most common ways for extending ParaView. However, ParaView plugin functionality goes far beyond that. The following sections cover some of these advanced plugins that can be written.</p>
<p>Applications use toolbars to provide easy access to commonly used functionality. It is possible to have plugins that add new toolbars to ParaView. The plugin developer implements his own C++ code to handle the callback for each button on the toolbar. Hence one can do virtually any operation using the toolbar plugin with some understanding of the ParaView Server Manager framework and the ParaView GUI components.</p>
<p>Please refer to <code>Examples/Plugins/SourceToolbar</code> for this section. There we are adding a toolbar with two buttons to create a sphere and a cylinder source. For adding a toolbar, one needs to implement a subclass for <a href="https://doc.qt.io/qt-5/qactiongroup.html">`QActionGroup`</a> which adds the <a href="https://doc.qt.io/qt-5/qaction.html">`QAction`</a>s for each of the toolbar button and then implements the handler for the callback when the user clicks any of the buttons. In the example <code>SourceToobarActions.{h,cxx}</code> is the <code>QActionGroup</code> subclass that adds the two tool buttons.</p>
<p>To build the plugin, the <code>CMakeLists.txt</code> file is:</p>
<p>```cmake </p>
<h1>This is a macro for adding QActionGroup subclasses automatically as toolbars.</h1>
<p>paraview_plugin_add_action_group( CLASS_NAME SourceToolbarActions GROUP_NAME "ToolBar/SourceToolbar" INTERFACES interfaces SOURCES sources)</p>
<h1>Now create a plugin for the toolbar. Here we pass the <code>interfaces</code> and</h1>
<h1><code>sources</code> returned by the above call.</h1>
<p>paraview_add_plugin(SourceToolbar VERSION "1.0" UI_INTERFACES ${interfaces} SOURCES ${sources} SourceToolbarActions.cxx) ```</p>
<p>For the <code>GROUP_NAME</code>, we are using <code>ToolBar/SourceToolbar</code>; here <code>ToolBar</code> is a keyword which implies that the action group is a toolbar (and shows up under <em>View &gt; Toolbars</em> menu) with the name <code>SourceToolbar</code>. When the plugin is loaded, this toolbar will show up with two buttons.</p>
<h4>Adding a Menu</h4>
<p>Adding a menu to the menu bar of the main window is almost identical to adding a toolbar. The only difference is that you use the keyword <code>MenuBar</code> in lieu of <code>ToolBar</code> in the <code>GROUP_NAME</code> of the action group. So if you change the <code>paraview_plugin_add_action_group</code> command above to the following, the plugin will add a menu titled <code>MyActions</code> to the menu bar.</p>
<p>```cmake paraview_plugin_add_action_group( CLASS_NAME SourceToolbarActions GROUP_NAME "MenuBar/MyActions" INTERFACES interfaces SOURCES sources) ```</p>
<p>If you give the name of an existing menu, then the commands will be added to that menu rather than create a new one. So, for example, if the <code>GROUP_NAME</code> is <code>MenuBar/File</code>, the commands will be added to the bottom of the <em>File</em> menu.</p>
<h4>Autostart Plugins</h4>
<p>This refers to a plugin which needs to be notified when ParaView starts up or the plugin is loaded which ever happens later and then notified when ParaView quits. Example is in <code>Examples/Plugins/Autostart</code> in the ParaView source. For such a plugin, we need to provide a <code>QObject</code> subclass (<code>pqMyApplicationStarter</code>) with methods that need to be called on startup and shutdown.</p>
<p>```cpp class pqMyApplicationStarter : public QObject { Q_OBJECT public: // Callback for startup. // This cannot take any arguments void onStartup();</p>
<p>// Callback for shutdown. // This cannot take any arguments void onShutdown(); }; ```</p>
<p>The <code>CMakeLists.txt</code> looks as follows:</p>
<p>```cmake </p>
<h1>Macro for auto-start plugins. We specify the class name and the methods to</h1>
<h1>call on startup and shutdown on an instance of that class. It returns the</h1>
<h1>interface and sources created in the variables passed to the <code>INTERFACES</code> and</h1>
<h1><code>SOURCES</code> arguments, respectively.</h1>
<p>paraview_plugin_add_auto_start( CLASS_NAME pqMyApplicationStarter # the class name for our class STARTUP onStartup # specify the method to call on startup SHUTDOWN onShutdown # specify the method to call on shutdown INTERFACES interfaces SOURCES sources)</p>
<h1>Create a plugin for this starter</h1>
<p>paraview_add_plugin(Autostart VERSION "1.0" UI_INTERFACES ${interfaces} SOURCES pqMyApplicationStarter.cxx ${interfaces}) ```</p>
<h4>Adding new Representations for 3D View using Plugins</h4>
<p>ParaView's 3D view the most commonly used view for showing polygonal or volumetric data. By default, ParaView provides representation-types for showing the dataset as surface, wireframe, points etc. It’s possible to add representations using plugins that extends this set of available representation types.</p>
<p>Before we start looking at how to write such a plugin, we need to gain some understanding of the 3D view and its representations. The 3D view uses 3 basic representation proxies for rendering all types of data:</p>
<ul>
<li>(representations, <code>UnstructuredGridRepresentation</code>) – for <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkUnstructuredGrid.html">vtkUnstructuredGrid</a></code> or a composite dataset consisting of <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkUnstructuredGrid.html">vtkUnstructuredGrid</a></code>.</li>
<li>(representations, <code>UniformGridRepresentation</code>) – for <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkImageData.html">vtkImageData</a></code> or a composite dataset consisting of <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkImageData.html">vtkImageData</a></code></li>
<li>(representations, <code>GeometryRepresentation</code>) – for all other data types.</li>
</ul>
<p>Each of these representation proxies are basically composite representation proxies that use other representation proxies to do the actual rendering, e.g., <code>GeometryRepresentation</code> uses <code>SurfaceRepresentation</code> for rendering the data as wireframe, points, surface, and surface-with-edges and <code>OutlineRepresentation</code> for rendering an outline for the data. Subsequently, the 3 composite representation proxies provide a property named <code>Representation</code> which allows the user to pick the representation type he wants to see the data as. The composite representation proxy has logic to enable one of its internal representations based on the type chosen by the user.</p>
<p>These 3 composite representation types are fixed and cannot be changed by plugins. What plugins can do is add more internal representations to any of these 3 composite representations to support new representations types that the user can choose using the representation type combo box on the display tab or in the toolbar.</p>
<div class="image">
<img src="images/Representationplugin.png"  alt="Representation type combo-box allowing user to choose the sub-representation to use"/>
</div>
<h5>Using a New Mapper</h5>
<p>In this example, we see how to integrate a special polydata mapper written in VTK into ParaView. Let’s say the mapper is called <code>vtkMySpecialPolyDataMapper</code> which is simply a subclass of <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkPainterPolyDataMapper.html">vtkPainterPolyDataMapper</a></code>. In practice, <code>vtkMySpecialPolyDataMapper</code> can internally use different painters to do perform special rendering tasks.</p>
<p>To integrate this mapper into ParaView, first we need to create a <code><a class="el" href="classvtkSMRepresentationProxy.html" title="Proxy for a representations. ">vtkSMRepresentationProxy</a></code> subclass for that uses this mapper. In this example, since the mapper is a simple replacement for the standard <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkPainterPolyDataMapper.html">vtkPainterPolyDataMapper</a></code>, we can define our representation proxy as a specialization of the <code>SurfaceRepresentation</code> as follows:</p>
<p>```xml &lt;ServerManagerConfiguration&gt; &lt;ProxyGroup name="representations"&gt; &lt;RepresentationProxy name="MySpecialRepresentation" class="vtkMySpecialRepresentation" processes="client|renderserver|dataserver" base_proxygroup="representations" base_proxyname="SurfaceRepresentation"&gt; &lt;Documentation&gt; This is the new representation type we are adding. This is identical to the SurfaceRepresentation except that we are overriding the mapper with our mapper. &lt;/Documentation&gt; &lt;/RepresentationProxy&gt; &lt;/ProxyGroup&gt; &lt;/ServerManagerConfiguration&gt; ```</p>
<p><code>vtkMySpecialRepresentation</code> is a subclass of <code><a class="el" href="classvtkGeometryRepresentationWithFaces.html" title="vtkGeometryRepresentationWithFaces extends vtkGeometryRepresentation to add support for rendering bac...">vtkGeometryRepresentationWithFaces</a></code> where in the constructor we simply override the mappers as follows:</p>
<p>```cpp vtkMySpecialRepresentation::vtkMySpecialRepresentation() { // Replace the mappers created by the superclass. this-&gt;Mapper-&gt;Delete(); this-&gt;LODMapper-&gt;Delete();</p>
<p>this-&gt;Mapper = vtkMySpecialPolyDataMapper::New(); this-&gt;LODMapper = vtkMySpecialPolyDataMapper::New();</p>
<p>// Since we replaced the mappers, we need to call SetupDefaults() to ensure // the pipelines are setup correctly. this-&gt;SetupDefaults(); } ```</p>
<p>Next we need to register this new type with the any (or all) of the 3 standard composite representations so that it will become available to the user to choose in the representation type combo box. To decide which of the 3 composite representations we want to add our representation to, think of the input data types our representation supports. If it can support any type of data set, then we can add our representation all the 3 representations (as is the case with this example). However if we are adding a representation for volume rendering of <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkUnstructuredGrid.html">vtkUnstructuredGrid</a></code> then we will add it only to the <code>UnstructuredGridRepresentation</code>. This is done by using the <code>Extension</code> XML tag. It simply means that we are extending the original XML for the proxy definition with the specified additions. Now to make this representation available as a type to the user, we use the <code>RepresentationType</code> element , with <code>text</code> used as the text shown for the type in the combo-box, <code>subproxy</code> specifies the name of representation subproxy to activate when the user chooses the specified type. Optionally one can also specify the <code>subtype</code> attribute, which if present is the value set on a property named <code>Representation</code> for the subproxy when the type is chosen. This allows for the subproxy to provide more than one representation type.</p>
<p>```xml &lt;ServerManagerConfiguration&gt; &lt;ProxyGroup name="representations"&gt; &lt;Extension name="GeometryRepresentation"&gt; &lt;Documentation&gt; Extends standard GeometryRepresentation by adding MySpecialRepresentation as a new type of representation. &lt;/Documentation&gt;</p>
<pre class="fragment">  &lt;RepresentationType
      subproxy="MySpecialRepresentation"
      text="Special Mapper"
      subtype="1" /&gt;

  &lt;SubProxy&gt;
    &lt;Proxy name="MySpecialRepresentation"
           proxygroup="representations"
           proxyname="MySpecialRepresentation"&gt;
    &lt;/Proxy&gt;
    &lt;ShareProperties subproxy="SurfaceRepresentation"&gt;
      &lt;Exception name="Input" /&gt;
      &lt;Exception name="Visibility" /&gt;
      &lt;Exception name="Representation" /&gt;
    &lt;/ShareProperties&gt;
  &lt;/SubProxy&gt;
&lt;/Extension&gt;
</pre><p> &lt;/ProxyGroup&gt; &lt;/ServerManagerConfiguration&gt; ```</p>
<p>The <code>CMakeLists.txt</code> file is not much different from what it would be like for adding a simple filter or a reader where the representation class is placed into the contained module.</p>
<p>Source code for this example is available under <code>Examples/Plugins/Representation</code> in the ParaView source directory.</p>
<h2>Examples</h2>
<p>The ParaView git repository contains many examples in the <code>Examples/Plugins</code> directory.</p>
<h2>Adding plugins to ParaView source</h2>
<p>There are several plugins that are included in ParaView source itself and are built as part of ParaView's build process. To add such a plugin to the ParaView build there are two options, adding it to the <code>ParaView/Plugins</code> directory is currently the only supported mechanism.</p>
<p>In general users should simply build their plugins separately, outside the ParaView source. However, when building ParaView statically, adding the plugin to be built as part of ParaView ensures that the static executables load the plugin, otherwise there is no mechanism for loading a plugin in statically built executables.</p>
<p>In your plugin source directory, ParaView searches for a file name <code>paraview.plugin</code> which provides ParaView with information about the plugin. This file should contain the following contents:</p>
<p>```cmake </p>
<h1>Comments are allowed.</h1>
<p>NAME PluginName DESCRIPTION A description of the plugin. This text is attached to the CMake option to build this plugin. REQUIRES_MODULES </p>
<h1>List of VTK modules required by the code contained in the plugin. This</h1>
<h1>allows ParaView to build the full set of requested modules if the plugin is</h1>
<h1>being built.</h1>
<p>VTK::CommonCore ```</p>
<p>If now the plugin is enabled (by the user or by default) by turning ON the <code>PARAVIEW_PLUGIN_ENABLE_PluginName</code> CMake option, then CMake will look for a <code>CMakeLists.txt</code> file next to the <code>paraview.plugin</code>. This file contains the calls to build the plugin including the <code>paraview_add_plugin</code> call, and building of any other libraries that the plugin needs.</p>
<p>A good place to start would be look at examples under <code>ParaView/Plugins</code> directory.</p>
<h2>Plugins in Static Applications</h2>
<p>It is possible to import plugins into a ParaView-based application at compile time. When building ParaView-based applications statically, this is the only option to bring in components from plugins. When built statically (i.e., with <code>BUILD_SHARED_LIBS</code> set to false), ParaView will automatically link and load plugins that were enabled via CMake by inserting the necessary <code>PV_PLUGIN_IMPORT_INIT</code> and <code>PV_PLUGIN_IMPORT</code> macros.</p>
<p>The code below shows how the <code>PV_PLUGIN</code> macros would be used to statically load plugins in custom applications:</p>
<p>```cpp #define PARAVIEW_BUILDING_PLUGIN #include "vtkPVPlugin.h"</p>
<p>// Adds required forward declarations. PV_PLUGIN_IMPORT_INIT(MyFilterPlugin) PV_PLUGIN_IMPORT_INIT(MyReaderPlugin)</p>
<p>class MyMainWindow : public QMainWindow { // .... };</p>
<p>MyMainWindow::MyMainWindow(...) { // ... after initialization ...</p>
<p>// Calls relevant callbacks to load the plugins and update the // GUI/Server-Manager PV_PLUGIN_IMPORT(MyFilterPlugin); PV_PLUGIN_IMPORT(MyReaderPlugin); } ```</p>
<h2>Pitfalls</h2>
<h3>*Tools &gt; Manage Plugins* is not visible!</h3>
<p>Plugins can only be loaded dynamically when ParaView is built with shared libraries. You must recompile ParaView with <code>BUILD_SHARED_LIBS=ON</code>.</p>
<h3>Compile error `invalid conversion from 'vtkYourFiltersSuperClass*' to 'vtkYourFilter*'`</h3>
<p>Any VTK object that needs to be treated as a filter or source has to be a <code><a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkAlgorithm.html">vtkAlgorithm</a></code> subclass. The particular superclass a filter is derived from has to be given not only in the standard C++ way:</p>
<p>```cpp class VTKMODULE_EXPORT vtkMyElevationFilter : public <a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkElevationFilter.html">vtkElevationFilter</a> ```</p>
<p>but additionally declared with help of the <code>vtkTypeMacro</code>. For the example given above:</p>
<p>```cpp class VTKMODULE_EXPORT vtkMyElevationFilter : public <a class="elRef" doxygen="/builds/gitlab-kitware-sciviz-ci/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkElevationFilter.html">vtkElevationFilter</a> { public: vtkTypeMacro(vtkMyElevationFilter, vtkElevationFilter); } ```</p>
<p>Otherwise, compiling the filter will fail with a variety of error messages (depending on superclass) like</p>
<p>``` vtkMyElevationFilter.cxx:19: error: no 'void vtkMyElevationFilter::CollectRevisions(std::ostream&amp;)' member function declared in class 'vtkMyElevationFilter' ``` or</p>
<p>``` vtkMyElevationFilterClientServer.cxx:97: error: invalid conversion from ‘vtkPolyDataAlgorithm*’ to ‘vtkICPFilter*’ ```</p>
<h3>Mysterious Segmentation Faults in Plugins that use Custom VTK Classes</h3>
<p>This primarily concerns plugins that make calls to your own custom <code>vtkMy</code> (or whatever you called it) library of VTK extensions.</p>
<p>Symptoms:</p>
<ul>
<li>The plugin will load, but causes a segfault when you try to use it.</li>
<li>If you use a debugger you may notice that in some cases when your code calls <code>vtkClassA.MethodB</code>, what actually gets called is <code>vtkClassC.MethodD</code>, where <code>MethodB</code> is a virtual member function. This is occurs because of different vtable entries in the Paraview-internal versions of the VTK libraries.</li>
</ul>
<p>The solution is to make sure that your <code>vtkMy</code> library is compiled against ParaView's internal VTK libraries. Even if you compiled VTK and ParaView using the same VTK sources, you <em>must not</em> link against the external VTK libraries. (The linker won't complain, because it will find all the symbols it needs, but this leads to unexpected behaviour.)</p>
<p>To be explicit, when compiling your <code>vtkMy</code> library, you must set the CMake variable <code>VTK_DIR</code> to point to the <code>VTK</code> subdirectory in the directory in which you built ParaView. (On my system, CMake automatically finds VTK at <code>/usr/lib/vtk-5.2</code>, and I must change <code>VTK_DIR</code> to <code>~/source/ParaView3/build/VTK</code>.)</p>
<h3>"Is not a valid Qt plugin" in Windows</h3>
<p>Make sure that all the DLLs that your plugin depends on are on the <code>PATH</code>. If in doubt, try placing your plugin and all its dependent DLLs in the <code>bin</code> directory of your build and load it from there.</p>
<h3>The system cannot find the path specified. <code>error MSB6006: "cmd.exe" exited with code 3.</code></h3>
<p>You may get an error like this when trying to build your plugin with Visual Studio:</p>
<p>``` 1&gt; CS Wrapping - generating vtkMyElevationFilterClientServer.cxx 1&gt; The system cannot find the path specified. 1&gt;C: Files\MSBuild\Microsoft.Cpp.0\Microsoft.CppCommon.targets(151,5): error MSB6006: "cmd.exe" exited with code 3. 1&gt;Done executing task "CustomBuild" &ndash; FAILED. ```</p>
<p>This is caused for a mismatch between the configuration you used when building ParaView (e.g. Debug, Release, etc.) and the configuration currently chosen for building your plugin. So ensure those match.</p>
<p>The problem is caused because inside the Linker properties there are references to the <code>*.lib</code> files, including the name of the directory that matches the configuration type, which may look something like <code>C:\Users\MyUser\ParaView-v4.2.0-build\lib\Release\vtkPVAnimation-pv4.2.lib</code>. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5 on Sat Aug 22 2020
</small></address>
<!-- KW:BEGIN -->
<!-- this adds the version selection header -->
<script type="text/javascript" src="/paraview-docs/paraview-version.js"></script>
<!-- KW:END -->
</body>
</html>
