<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ParaView: Anatomy of Catalyst Python Module (Version 2.0)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea" style="height: 56px;">
  <div class="pv-title-cpp title-line">
    <div class="title-line">
      <img class="pv-logo" src="paraview-logo-small.png" />
    </div>
    <div class="langSwitch title-line"></div>
  </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Anatomy of Catalyst Python Module (Version 2.0) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page describes the details of Python modules intended for use in Catalyst. This page covers features supported by ParaView 5.9 and later i.e. version 2.0.</p>
<h2>Basics </h2>
<p>Catalyst Python modules are simply Python scripts that use the <code>paraview</code> package to define data analysis and visualization pipelines. They can be structured as a standard <code>.py</code> file or collection of <code>.py</code> files (i.e. a Python package). The former is suitable for simple analysis scripts, while the latter is intended for more complex pipelines and use-cases.</p>
<p>When structured as a package, the directory containing the package (and all the <code>.py</code> files (modules) that comprise the package) can be zipped in to a <code>.zip</code> file with same name as as the package. Directly loading such a <code>.zip</code> archive is also supported by Catalyst. In fact, this is the recommended way for production runs on HPC systems.</p>
<p>Catalyst adaptor developers can use <code><a class="el" href="classvtkCPPythonScriptV2Pipeline.html" title="vtkCPPipeline for Catalyst Python script / package version 2.0">vtkCPPythonScriptV2Pipeline</a></code> to add <a class="el" href="classvtkCPPipeline.html" title="Generic interface for operating on pipelines.">vtkCPPipeline</a> objects to the co-processor for version 2.0 Catalyst Python modules structured as a single <code>.py</code> file, or a package or <code>.zip</code> containing a package.</p>
<p>Simulation codes that use Python for interfacing with Catalyst can leverage <code>paraview.catalyst.bridge</code> to deal with all the Catalyst initialization and update complexity. For such codes can use <code>paraview.catalyst.bridge.add_pipeline_v2</code> to register version 2.0 Catalyst Python scripts, packages or package-zips.</p>
<h2>Execution </h2>
<p>Now, let's look at how and when the Python code in the Catalyst Python module is executed. The Catalyst co-processor (<a class="el" href="classvtkCPProcessor.html" title="There are 3 distinct phases for the operation of a co-processor.">vtkCPProcessor</a>) splits in situ pipeline execution into two stages: first is called <b>RequestDataDescription</b>, where meta-data is collected / updated and <b>CoProcess</b> where the analysis pipeline execution takes place.</p>
<p>The Catalyst module gets loaded, rather <em>imported</em>, the first time <b>RequestDataDescription</b> gets called. Thus, any statements that you have in the module script (or <code>__init__.py</code> for packages) will get executed at that point. This implies the following:</p>
<ol type="1">
<li>Since RequestDataDescription pass is intended for gathering meta-data, it is not assured that the simulation will provide any valid data at this stage. This means that any code that will get executed at this stage cannot depend on simulation data to be available.</li>
<li>If you are using Python package instead of a script or module, Python defines the entry point for the package as a file named <code>__init__.py</code>. Thus, any code you have in this file will get executed. Any code in other .py files in the package need not get executed unless explicitly imported in the <code>__init__.py</code> file.</li>
</ol>
<p>At the very least, the module must define a global variable named <code>options</code> which defines co-processing options like frequency of updates, output directories, etc. The following is the typical way of creating and initializing this options instance.</p>
<div class="fragment"><div class="line"><span class="comment"># catalyst options</span></div><div class="line"><span class="keyword">from</span> paraview.catalyst <span class="keyword">import</span> Options</div><div class="line">options = Options()</div><div class="line">options.ImageExtractsOutputDirectory = <span class="stringliteral">&quot;....&quot;</span></div><div class="line">options.DataExtractsOutputDirectory = <span class="stringliteral">&quot;....&quot;</span></div><div class="line"></div><div class="line"><span class="comment"># global trigger params (optional)</span></div><div class="line">options.GlobalTrigger.UseStartTimeStep = ... <span class="comment"># default=False</span></div><div class="line">options.GlobalTrigger.StartTimeStep = ...    <span class="comment"># default=0</span></div><div class="line">options.GlobalTrigger.UseEndTimeStep = ..    <span class="comment"># default=False</span></div><div class="line">options.GlobalTrigger.EndTimeStep = ...      <span class="comment"># default=0</span></div><div class="line">options.GlobalTrigger.Frequency = ...        <span class="comment"># default=1</span></div><div class="line"></div><div class="line"><span class="comment"># live params (optional)</span></div><div class="line">options.EnableCatalystLive = ...                    <span class="comment"># default=False</span></div><div class="line">options.CatalystLiveURL = ...                       <span class="comment"># default=&quot;localhost:2222&quot;</span></div><div class="line">options.CatalystLiveTrigger.UseStartTimeStep = ...  <span class="comment"># default=False</span></div><div class="line">options.CatalystLiveTrigger.StartTimeStep = ...     <span class="comment"># default=0</span></div><div class="line">options.CatalystLiveTrigger.UseEndTimeStep = ...    <span class="comment"># default=False</span></div><div class="line">options.CatalystLiveTrigger.EndTimeStep = ...       <span class="comment"># default=0</span></div><div class="line">options.CatalystLiveTrigger.Frequency = ...         <span class="comment"># default=1</span></div></div><!-- fragment --><p>Once the module is imported, Catalyst evaluates the GlobalTrigger and CatalystLiveTrigger parameters (if EnableCatalystLive is set to True) to determine whether to continue with subsequent steps. If the trigger criteria is not statisfied further processing of the Catalyst modules is skipped until new <b>RequestDataDescription</b> when the trigger criteria is reevaluated.</p>
<p>Next, Catalyst checks if the module has a function called <code>catalyst_request_data_description</code>. If defined, this function is called with current <a class="el" href="classvtkCPDataDescription.html" title="This class provides the description of the data for the coprocessor pipelines.">vtkCPDataDescription</a> object as argument. This is only intended for very custom and advanced use-cases, including testing. Generally, users should not need to rely on any such <code>catalyst_</code> functions.</p>
<p>After <b>RequestDataDescription</b> stage, the Catalyst co-processor will trigger <b>CoProcess</b> stage, unless it was skipped (based on GlobalTrigger and CatalystLiveTrigger parameters). In <b>CoProcess</b>, simulation has made its data available for analysis. Thus code can now rely on that for setup or execution. First time <b>CoProcess</b> gets called, Catalyst looks for presence of a global variable named <b>scripts</b> in the module. When present, this is a list of names of submodules that have code to setup analysis and visualization pipelines. Typically, these are simply ParaView Python scripts that define the visualization state &ndash; same as the scripts used for <code>pvpython</code> or <code>pvbatch</code>. All submodules list in <b>scripts</b> variable are imported at this point. Since this happens during <b>CoProcess</b>, these scripts can safely rely on valid simulation data being present to setup pipeline state e.g. setting up filter parameters, color map ranges, etc. Note, this happens only the first time <b>CoProcess</b> is called, i.e. subsequent <b>CoProcess</b> calls don't cause the analysis scripts to be reimported.</p>
<div class="fragment"><div class="line"><span class="comment"># this will cause a `pipeline.py` from the Python package to be imported</span></div><div class="line"><span class="comment"># in first call to CoProcess</span></div><div class="line">scripts = [<span class="stringliteral">&quot;pipeline&quot;</span>]</div></div><!-- fragment --><p>The submodule may define visualization state that includes extract generators for generating extracts. These extract generators may have their own triggers. Before proceeding further, Catalyst now checks if any triggers defined are activated for the current timestep. If not, the further processing of the module is skipped.</p>
<p>Next, when not skipped, Catalyst checks for a function called <code>catalyst_initialize</code> in the module and all of the submodules imported via <code>scripts</code>. If present, this function is called, again with the current <a class="el" href="classvtkCPDataDescription.html" title="This class provides the description of the data for the coprocessor pipelines.">vtkCPDataDescription</a> object as argument starting with the module and then on each of the submodules in the same order as in the <code>scripts</code> list. This is only called once; subsequent calls to <b>CoProcess</b> will skip this step. When not using a package, for example, <code>catalyst_initialize</code> is a good function to implement code to setup you analysis pipeline since its called once and you're assured that the simulation data is valid &ndash; which is often necessary when setting up visualization pipelines.</p>
<p>Next, Catalyst optionally calls the function <code>catalyst_coprocess</code>, if present, on the module and all the submodules imported via <code>scripts</code> in same order as <code>catalyst_initialize</code>. Again, this is generally not needed except for highly customized / advanced use-cases.</p>
<p>Next, Catalyst will generate extracts using extract generators created by the module (or its submodules). Finally, if <code>EnableCatalystLive</code> is true and the CatalystLiveTrigger is satisfied, Catalyst attempts to connect to ParaView GUI at the <code>CatalystLiveURL</code> for Live.</p>
<p>These <b>RequestDataDescription</b> and <b>CoProcess</b> stages are repeated for the entire simulation run. On termination, Catalyst optionally calls <code>catalyst_finalize</code> on the module and submodules imported via <code>scripts</code>. Here, however, the submodules are finalized before that the top-level module/package is finalized.</p>
<h2>Visualization Pipeline </h2>
<p>ParaView Python API, exposed via the <code>paraview.simple</code> module, is used to define the visualization and data pipeline. The API mimics actions one would take the GUI. For example, simple script to create a <b>Wavelet</b> source slice it, looks as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> paraview.simple <span class="keyword">import</span> *</div><div class="line"></div><div class="line">wavelet1 = Wavelet(registrationName=<span class="stringliteral">&#39;Wavelet1&#39;</span>)</div><div class="line"></div><div class="line"><span class="comment"># create a new &#39;Slice&#39;</span></div><div class="line">slice1 = Slice(registrationName=<span class="stringliteral">&#39;Slice1&#39;</span>, Input=wavelet1)</div><div class="line">slice1.SliceType = <span class="stringliteral">&#39;Plane&#39;</span></div><div class="line">slice1.SliceType.Normal = [0, 0, 1]</div></div><!-- fragment --><p>This same code can be used in a Catalyst Python script to setup the visualization pipeline. The only thing to note is that we need a mechanism to indicate which of the data-producers in the pipeline should be replaced by the data generated by the simulation. In Catalyst, the data produced by the simulation is available on named channels. Thus, we need to identify which named-channel corresponds to which data data-producer in the pipeline. For that, we use the <code>registrationName</code> attribute. In the Python script, when creating a source or a filter, one can pass in an optional argument <code>registrationName</code>. When the script is being executed within Catalyst, Catalyst looks to see if the <code>registrationName</code> matches the name of a known channel. If so, the data producer type requested (in this case Wavelet) is ignored and instead is replaced by a producer that puts out simulation data on that channel.</p>
<p>The <code>paraview.demos.wavelet_miniapp</code> is a miniapp that acts as a simulation producing a time value <code><a class="elRef" doxygen="/home/kitware/dashboards/buildbot/paraview_master-vall-linux-shared-release_adios2_doc_extdeps_gui_mpi_python3/build/Utilities/Doxygen/vtkNightlyDoc.tag:http://www.vtk.org/doc/nightly/html/" href="http://www.vtk.org/doc/nightly/html/classvtkImageData.html">vtkImageData</a></code> dataset. So we can use it to run the above script.</p>
<p>To do that, let's create a Python package. Create a directory, say <code>/tmp/sample</code> with the following contents:</p>
<div class="fragment"><div class="line">/tmp/sample/</div><div class="line">/tmp/sample/__init__.py</div><div class="line">/tmp/sample/pipeline.py</div></div><!-- fragment --><p>The <code>__init__.py</code> looks as follows: </p><div class="fragment"><div class="line"><span class="keyword">from</span> paraview.catalyst <span class="keyword">import</span> Options</div><div class="line">options = Options()</div><div class="line"></div><div class="line">scripts = [<span class="stringliteral">&#39;pipeline&#39;</span>]</div></div><!-- fragment --><p>The <code>pipeline.py</code> is simply the script shown earlier to create Wavelet and slice it.</p>
<p>Now, we run the miniapp with this analysis module as follows:</p>
<div class="fragment"><div class="line">&gt; pvpython -m paraview.demos.wavelet_miniapp \</div><div class="line">           --script /tmp/sample</div></div><!-- fragment --><p>This will produce the following output </p><div class="fragment"><div class="line">(   0.467s) [main thread     ]              bridge.py:18    WARN| Warning: ParaView has been initialized before `initialize` is called</div><div class="line">timestep: 1/100</div><div class="line">(   1.942s) [main thread     ]              detail.py:86    WARN| script may not depend on simulation data; is that expected?</div><div class="line">timestep: 2/100</div><div class="line">(   1.994s) [main thread     ]              detail.py:86    WARN| script may not depend on simulation data; is that expected?</div><div class="line">....</div></div><!-- fragment --><p>The warning message *"script may not depend on simulation data; is that expected?"* tells us that the script it not affected by any data the simulation is producing since none of its data producers have been replaced by a named channel. The default channel name that <code>wavelet_miniapp</code> uses is <b>input</b>. We can either change the <code>registrationName</code> for the <code>Wavelet</code> source in <code>pipeline.py</code> to <code>input</code> or pass optional argument <code>-c</code> to the <code>wavelet_miniapp</code> which lets us rename the channel as follows:</p>
<div class="fragment"><div class="line">&gt; ./bin/pvpython -m paraview.demos.wavelet_miniapp --script-version 2 -s /tmp/sample -c Wavelet1</div><div class="line">(   0.458s) [main thread     ]              bridge.py:18    WARN| Warning: ParaView has been initialized before `initialize` is called</div><div class="line">timestep: 1/100</div><div class="line">timestep: 2/100</div><div class="line">timestep: 3/100</div><div class="line">...</div></div><!-- fragment --><p>The script here does nothing significant so we don't see any results. Here's a tweak to the <code>pipeline.py</code> to make it show the rendering results for the slice.</p>
<div class="fragment"><div class="line"><span class="comment"># pipeline.py</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> paraview.simple <span class="keyword">import</span> *</div><div class="line"></div><div class="line">wavelet1 = Wavelet(registrationName=<span class="stringliteral">&#39;Wavelet1&#39;</span>)</div><div class="line"></div><div class="line">slice1 = Slice(registrationName=<span class="stringliteral">&#39;Slice1&#39;</span>, Input=wavelet1)</div><div class="line">slice1.SliceType = <span class="stringliteral">&#39;Plane&#39;</span></div><div class="line">slice1.SliceType.Normal = [0, 0, 1]</div><div class="line"></div><div class="line">Show()</div><div class="line">view = Render()</div><div class="line"></div><div class="line"><span class="keyword">def </span>catalyst_coprocess(*args):</div><div class="line">    <span class="keyword">global</span> view</div><div class="line">    ResetCamera(view)</div><div class="line">    Render(view)</div></div><!-- fragment --><p>Now, when you launch the <code>wavelet_miniapp</code>, it will show the rendering results on the screen as the simulation advances.</p>
<p>In this example, we are using <code>catalyst_coprocess</code> callback described earlier to execute certain actions per timestep. A more advanced analysis script would use extract generators, in which case <code>catalyst_coprocess</code> is rarely needed.</p>
<p>Also note, in this example we simply use a directory for the Python package instead of archiving it in a <code>.zip</code>. This is useful for development and debugging purposes. However, for HPC / production runs, it's recommended that you create an archive once the package is finalized.</p>
<h2>Debugging </h2>
<p>The <code>pvpython</code>/<code>pvbatch</code> executables can be launched with a <code>-l</code> argument to generate detailed logs as follows:</p>
<div class="fragment"><div class="line">&gt; pvpython -l=/tmp/log.txt,TRACE -m paraview.demos.wavelet_miniapp ...</div></div><!-- fragment --><p>Here, a <code>/tmp/log.txt</code> will all logging output will be generated. You can also elevate Catalyst-generated log to a higher level and log that, for example, the following will elevate catalyst log level to INFO and log all INFO messages to <code>/tmp/infolog.txt</code></p>
<div class="fragment"><div class="line">&gt; env PARAVIEW_LOG_CATALYST_VERBOSITY=INFO \</div><div class="line">      pvpython -l=/tmp/infolog.txt,INFO -m paraview.demos.wavelet_miniapp ...</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15 on Tue Jul 21 2020
</small></address>
<!-- KW:BEGIN -->
<!-- this adds the version selection header -->
<script type="text/javascript" src="/paraview-docs/paraview-version.js"></script>
<!-- KW:END -->
</body>
</html>
